'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * A router is a middleware(function) which has many routes.
 *
 * `req.basePath` represents current router/route's context(or position).
 * See there are router A and router B, and their relations are described by
 * `routerA.use('/a', routerB). So (router B's basePath) = (router A's basePath) + '/a'.
 * See there are router A and route A1, and their relations are described by
 * `routerA.use('/a', routeA1). So (route A1's basePath) = (router A's basePath) + '/a'.
 *
 * Why set the basePath on req dynamically? for the path pattern may be regexp.
 */

const compose = require('use-compose');
const VERBS = require('./verbs');

var _require = require('./route');

const addRouteFactory = _require.addRouteFactory,
      matchRoute = _require.matchRoute;

const bindExpressVerbs = require('./express');

function createRouter() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // router.basePath = ''; // prefix path of the router, eg: <empty>, /a, /a/b/c
  router.routes = [];

  // the router instance
  function router(req, resp, next) {
    const routerBasePath = req.basePath || '';
    return compose(router.routes, { beforeRunMiddleware: route => {
        const match = matchRoute(routerBasePath, req, route);
        if (!match) return false;

        const params = match.params,
              matchPath = match.path;


        if (options.params) req.params = _extends({}, options.params, params);else req.params = params;

        // set req.basePath for the route(middleware)
        req.basePath = routerBasePath + matchPath;
        return true;
      } }).call(this, req, resp, () => {
      req.basePath = routerBasePath; // restore basePath
      return next && next();
    });
  }

  // use('/a') will match /a, /a/b
  router.use = addRouteFactory(router, true, false);

  // all|get|post('/a') will only match /a, not match /a/b
  router.all = addRouteFactory(router, true, true);
  VERBS.forEach(verb => {
    router[verb] = addRouteFactory(router, verb.toUpperCase(), true);
  });

  bindExpressVerbs(router);

  return router;
}

module.exports = createRouter;